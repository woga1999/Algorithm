```java
class Solution {
    int[][] board =  new int[11][11];
    boolean[][][][] ch = new boolean[11][11][11][11];
    int dx[] = {-1,1,0,0};
    int dy[] = {0,0,-1,1};
    
    public int solution(String dirs) {
        int answer = 0;
        int N = dirs.length();
        int x = 5, y = 5;
        for(int i=0; i<N; i++){
            char dir = dirs.charAt(i);
            int nx = x, ny = y;
            if(dir == 'U'){
                nx = x + dx[0];
                ny = y + dy[0];
            }else if(dir == 'D'){
                nx = x + dx[1];
                ny = y + dy[1];  
            }else if(dir == 'R'){
                nx = x + dx[3];
                ny = y + dy[3];
            }else if(dir == 'L'){
                nx = x + dx[2];
                ny = y + dy[2];
            }
            if(nx < 0 || ny <0 || ny>10 || nx>10) continue;
            if(!ch[x][y][nx][ny]) answer++;
            ch[x][y][nx][ny] = true;
            x = nx; y=ny;
        }
        return answer;
    }
}
```

# 썸머윈터 인턴쉽 코테 준비



## 멀쩡한 사각형

[코딩테스트 연습 - 멀쩡한 사각형](https://programmers.co.kr/learn/courses/30/lessons/62048)

- 22.2점

    ```cpp
    #include <cmath>

    using namespace std;

    long long solution(int w,int h) {
        long long answer = 0;
        if(w==h){
            answer = (long long)w*h;
            answer -= w;
        }else{
            long long val = (long long)(w*w) + (h*h);
            val = sqrt(val);
            bool isOdd = true;
            if(h % 2 ==0 && w%2==0) isOdd=false;
            if(isOdd) val+=1;
            else val += 2;
            answer = (long long)(w*h) - val;
        }
        return answer;
    }
    ```



## 스킬트리

[코딩테스트 연습 - 스킬트리](https://programmers.co.kr/learn/courses/30/lessons/49993?language=cpp)

- 28.6점

  ```cpp
  #include <string>
  #include <vector>
  #include <unordered_map>
  
  using namespace std;
  
  int solution(string skill, vector<string> skill_trees) {
  	int answer = 0;
  	unordered_map<char, int> m;
  	for (int i = 0; i < skill.size(); i++) {
  		m[skill[i]] = i;
  	}
  	int N = skill_trees.size();
  	for (int i = 0; i < skill_trees.size(); i++) {
  		int index = -1;
  		char tmp = ' ';
  		bool check = false;
  		vector<bool> ch(N);
  		for (int j = 0; j < skill_trees[i].size(); j++) {
  			if (m.find(skill_trees[i][j]) != m.end() && index < m[skill_trees[i][j]]) {
  				index = m[skill_trees[i][j]];
  				tmp = skill_trees[i][j];
  				if (index > 0 && !ch[index - 1]) {
  					check = false;
  					break;
  				}
  				ch[index] = true;
  				check = true;
  			}
  			else if(m.find(skill_trees[i][j]) != m.end() && index > m[skill_trees[i][j]]){
  				check = false;
  				break;
  			}
  		}
  		if (check) answer++;
  	}
  	return answer;
  }
  ```

[[프로그래머스\] 스킬 트리](https://greenapple16.tistory.com/73)



## 방문 길이

[코딩테스트 연습 - 방문 길이](https://programmers.co.kr/learn/courses/30/lessons/49994)



- 10점

  ```cpp
  #include <string>
  using namespace std;
  
  int board[10][10];
  int dx[] = {-1,1,0,0};
  int dy[] = {0,0,-1,1};
  bool ch[10][10];
  
  int solution(string dirs) {
      int answer = 0;
      int x = 5, y = 5;
      for(int i=0; i<dirs.size(); i++){
          int nx = x, ny = y;
          if(dirs[i]=='U'){
              nx = x + dx[0];
              ny = y + dy[0];
          }else if(dirs[i] == 'D'){
              nx = x + dx[1];
              ny = y + dy[1]; 
          }else if(dirs[i] == 'R'){
              nx = x + dx[3];
              ny = y + dy[3];
          }else if(dirs[i] == 'L'){
              nx = x + dx[2];
              ny = y + dy[2];
          }
          if(nx>10 || ny>10 || nx<0 || ny<0) continue;
          if(!ch[x][y]) answer++;
          ch[x][y] = true;
          x= nx; y = ny;
      }
      
      return answer;
  }
  ```



- 35점

  ```java
  class Solution {
      int[][] board =  new int[11][11];
      boolean[][][][] ch = new boolean[11][11][11][11];
      int dx[] = {-1,1,0,0};
      int dy[] = {0,0,-1,1};
      
      public int solution(String dirs) {
          int answer = 0;
          int N = dirs.length();
          int x = 5, y = 5;
          for(int i=0; i<N; i++){
              char dir = dirs.charAt(i);
              int nx = x, ny = y;
              if(dir == 'U'){
                  nx = x + dx[0];
                  ny = y + dy[0];
              }else if(dir == 'D'){
                  nx = x + dx[1];
                  ny = y + dy[1];  
              }else if(dir == 'R'){
                  nx = x + dx[3];
                  ny = y + dy[3];
              }else if(dir == 'L'){
                  nx = x + dx[2];
                  ny = y + dy[2];
              }
              if(nx < 0 || ny <0 || ny>10 || nx>10) continue;
              if(!ch[x][y][nx][ny]) answer++;
              ch[x][y][nx][ny] = true;
              x = nx; y=ny;
          }
          return answer;
      }
  }
  ```



## 쿠키 구입

[코딩테스트 연습](https://programmers.co.kr/learn/challenges?selected_part_id=6174)

어떻게 풀어? 생각안남..

개천재적 풀이...

- 먼저, 바구니를 두개를 정한다
- 그리고 바구니 A는 그 앞으로 바구니 B는 그 뒤로
- 완전탐색처럼 N까지 다 돌아가면서 Sum이 같을 때 max값을 정한다.



- 100점

  ```java
  class Solution {
      public int solution(int[] cookie) {
          int answer = -1;
          int frontIndex = 0, frontSum = 0 ,backIndex = 0, backSum = 0;
          int N = cookie.length;
          for(int i=0; i<N-1; i++){
              frontIndex = i;
              frontSum = cookie[i];
              backIndex = i+1;
              backSum = cookie[i+1];
              for(int j=0; j<N; j++){
                  if(frontSum == backSum){
                      answer = Math.max(answer, frontSum);
                  }
                  if(frontIndex >0 && frontSum <= backSum){
                      frontIndex--;
                      frontSum += cookie[frontIndex];
                  }else if(backIndex<N-1 && frontSum >= backSum){
                      backIndex++;
                      backSum += cookie[backIndex];
                  }
              }
          }
          return answer == -1? 0 : answer;
      }
  }
  ```





## 소수 만들기

[코딩테스트 연습 - 소수 만들기](https://programmers.co.kr/learn/courses/30/lessons/12977)

- 53.8

  ```cpp
  #include <vector>
  #include <iostream>
  using namespace std;
  
  int result;
  bool isPrime[50000];
  
  void dfs(int cnt, int sum, int index, vector<int> n){
      if(cnt==3){
          if(isPrime[sum]) result++;
          return;
      }
      for(int i=index; i<n.size(); i++){
          dfs(cnt+1, sum+n[i] ,i+1, n);
      }
  }
  int solution(vector<int> nums) {
      for(int i=2; i<=50000; i++){
          for(int j=2; j*j<=i; j++){
              if(i % j ==0) {
                  isPrime[j] = true;
                  break;
              }
          }
      }
      dfs(0,0,0,nums);
      return result;
  }
  ```





- 100점

  ```cpp
  #include <vector>
  #include <iostream>
  using namespace std;
  
  int result;
  
  bool isPrime(int n){
      for(int i=2; i<n; i++){
          if(n % i == 0) return false;
      }
      return true;
  }
  
  void dfs(int cnt, int sum, int index, vector<int> n){
      if(cnt==3){
          if(isPrime(sum)) result++;
          return;
      }
      for(int i=index; i<n.size(); i++){
          dfs(cnt+1, sum+n[i] ,i+1, n);
      }
  }
  int solution(vector<int> nums) {
     
      dfs(0,0,0,nums);
      return result;
  }
  ```



## 점프와 순간 이동

[코딩테스트 연습 - 점프와 순간 이동](https://programmers.co.kr/learn/courses/30/lessons/12980)

이상함.. 이상하게 품.. 왜이래 0 점..

아니 이걸 어떻게 그렇게 생각해? 아...

헐

현재까지 온 거리니깐 그러네 TOP-DoWN..

- 100점 (풀이 봄)

  ```cpp
  #include <iostream>
  using namespace std;
  
  int solution(int n)
  {
      int ans = 0;
      while(n>0){
          if(n%2==0){
              n/=2;
          }else{
              n -= 1;
              ans++;
          }
      }
      return ans;
  }
  ```