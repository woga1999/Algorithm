# 백준 골드 문제

## 최단경로

[1753번: 최단경로](https://www.acmicpc.net/problem/1753)

- 논리가 좀 이상한듯..?

    ```cpp
    #include <string>
    #include <vector>
    #include <set>
    #include <unordered_map>
    #include <iostream>
    #include<algorithm>
    #include <queue>
    #include <map>

    using namespace std;

    bool comp(pair<int, int> a, pair<int, int> b) {
    	if (a.second < b.second) return true;
    	return false;
    }
    int V, E;
    vector<pair<int, int>> arr[20001];
    bool ch[20001];

    int dfs(int start, int end, int weight, int cnt) {
    	if (start == end) {
    		return weight;
    	}
    	if (cnt > V) {
    		return -1;
    	}
    	for (int i = 0; i < arr[start].size(); i++) {
    		if (ch[arr[start][i].first]) continue;
    		ch[arr[start][i].first] = true;
    		dfs(arr[start][i].first, end, weight + arr[start][i].second, cnt + 1);
    		ch[arr[start][i].first] = false;
    	}
    }

    int main() {
    	cin.tie(NULL);
    	ios_base::sync_with_stdio(false);
    	
    	cin >> V >> E;
    	int startV;
    	cin >> startV;
    	for (int i = 0; i < E; i++) {
    		int u, v, w;
    		cin >> u >> v >> w;
    		arr[u].push_back({ v,w });
    	}
    	for (int i = 1; i <= V; i++) {
    		sort(arr[i].begin(), arr[i].end(),comp);
    	}
    	for (int i = 1; i <= V; i++) {
    		if (i == startV) {
    			printf("0\n");
    			continue;
    		}
    		int res = dfs(startV, i, 0, 0);
    		if (res == -1) printf("INF\n");
    		else printf("%d\n", res);
    	}

    	return 0;
    }
    ```

[[백준] 1753번 C/C++ 풀이 _ 최단경로](http://melonicedlatte.com/algorithm/2018/03/04/061153.html)

다익스트라 응용 문제였다 그냥 벡터로 풀면 V^2 되서 시간초과 되니깐 우선순위로 해결해야한다. 어렵다 약간 이해 안됨..

우선순위 큐

- first를 처음으로 비교함
- sort를 최소힙으로 하는데 이게 제일 큰 값이 맨 위에 있는 식

- 정답소스 : 우선순위 큐

    ```cpp
    #include <iostream>
    #include <string>
    #include <vector>
    #include <queue>
    #include <algorithm>

    #define INF 987654321

    using namespace std;

    int dis[20001];
    vector<pair<int,int>> arr[20001];
    priority_queue<pair<int,int>> pq;

    int main() {
    	ios_base::sync_with_stdio(false);
    	cin.tie(NULL);
    	int V, E, start;
    	
    	scanf("%d %d", &V, &E);
    	scanf("%d", &start);
    	int a, b, c;
    	for (int i = 0; i < E; i++) {
    		scanf("%d %d %d", &a, &b, &c);
    		arr[a].push_back({ b,c });
    	}
    	for (int i = 0; i <= V; i++) dis[i] = INF;
    	dis[start] = 0;
    	pq.push({ 0,start });
    	
    	while (!pq.empty()) {
    		int now = pq.top().second;
    		int cost = pq.top().first;
    		pq.pop();
    		for (int i = 0; i < arr[now].size(); i++) {
    			int new_val = dis[now] + arr[now][i].second;
    			int before_val = dis[arr[now][i].first];
    			if(new_val < before_val){
    				dis[arr[now][i].first] = new_val;
    				pq.push({ -1 * new_val, arr[now][i].first });
    			}
    		}
    	}
    	for (int i = 1; i <= V; i++) {
    		if (dis[i] != INF) printf("%d\n", dis[i]);
    		else printf("INF\n");
    	}
    	return 0;
    }
    ```